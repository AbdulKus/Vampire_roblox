local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local Lighting = game:GetService("Lighting")
local GuiService = game:GetService("GuiService")

local Utility = require(script:WaitForChild("Utility"))
local UIBuilder = require(script:WaitForChild("UIBuilder"))

local clamp = Utility.clamp
local lerp = Utility.lerp
local dist = Utility.dist
local clearChildren = Utility.clearChildren

local lp = Players.LocalPlayer
local cam = workspace.CurrentCamera

local BASE_W = 220
local BASE_H = 130
local WORLD_W = 2200
local WORLD_H = 1400
local FLOOR_Y = 8

local STATE_TITLE = 0
local STATE_PLAY = 1
local STATE_OVER = 2
local STATE_LEVEL = 3

local FONT_UI = Enum.Font.Arcade

UIBuilder.setupPostFX(Lighting)

local constants = {
BASE_W = BASE_W,
BASE_H = BASE_H,
WORLD_W = WORLD_W,
WORLD_H = WORLD_H,
FONT_UI = FONT_UI,
}

local UI = UIBuilder.createUI(lp, constants)
local spriteFactory = UIBuilder.createSpriteFactory(UI, constants)
UIBuilder.rebuildScanlines(UI, constants)
UIBuilder.updateScale(UI, cam, constants)
cam:GetPropertyChangedSignal("ViewportSize"):Connect(function()
UIBuilder.updateScale(UI, cam, constants)
end)

local mkPixelCross = spriteFactory.mkPixelCross
local mkCenteredCrossIcon = spriteFactory.mkCenteredCrossIcon
local mkPlayerSprite = spriteFactory.mkPlayerSprite
local mkEnemySprite = spriteFactory.mkEnemySprite
local mkBulletSprite = spriteFactory.mkBulletSprite
local mkXpSprite = spriteFactory.mkXpSprite
local mkPickupSprite = spriteFactory.mkPickupSprite
local setupGrid = spriteFactory.setupGrid
local mkPixelRing = spriteFactory.mkPixelRing

local gridV, gridH, borderContainer = setupGrid()

local function canvasToWorld(cx, cy, camX, camY)
	return camX + (cx - BASE_W*0.5), camY + (cy - BASE_H*0.5)
end

local function normScreenXY(x, y)
	local inset = GuiService:GetGuiInset()
	return x - inset.X, y - inset.Y
end

local function screenToCanvas(sx, sy)
	local sc = UI.scale.Scale
	local absPos = UI.canvasHolder.AbsolutePosition
	local x, y = normScreenXY(sx, sy)
	local cx = (x - absPos.X) / sc
	local cy = (y - absPos.Y) / sc
	return cx, cy
end

local upgrades = {
	{ id=0, name="DMG +1", desc="BULLETS HIT HARDER" },
	{ id=1, name="FIRE RATE", desc="SHOOT FASTER" },
	{ id=2, name="PICKUP RADIUS", desc="COLLECT FARTHER" },
	{ id=3, name="MULTI SHOT", desc="MORE BULLETS" },
	{ id=4, name="BACK SHOT", desc="SHOOT BEHIND" },
	{ id=5, name="SIDE SHOT", desc="LEFT AND RIGHT" },
	{ id=6, name="AURA", desc="PASSIVE DAMAGE" },
	{ id=7, name="PIERCE", desc="BULLETS GO THROUGH" },
	{ id=8, name="DASH CD", desc="DASH MORE OFTEN" },
	{ id=9, name="MAX HP +1", desc="TOUGHER BODY" },
	{ id=10, name="BULLET SPEED", desc="FASTER PROJECTILES" },
	{ id=11, name="CRIT", desc="RARE BIG HITS" }
}

local state = STATE_TITLE
local score = 0
local bestScore = 0

local spawnTimer = 0
local spawnInterval = 1.05
local shakeT = 0
local shakeAmp = 0

local function shake(t, amp)
	shakeT = math.max(shakeT, t)
	shakeAmp = math.max(shakeAmp, amp)
end

local function setState(s)
	state = s
	UI.title.Visible = (s == STATE_TITLE)
	UI.over.Visible = (s == STATE_OVER)
	UI.lvl.Visible = (s == STATE_LEVEL)
end

local parts = {}
local function spawnParticle(x, y, vx, vy, life, kind)
	local col = Color3.fromRGB(255,255,255)
	if kind == 0 then col = Color3.fromRGB(255,255,255)
	elseif kind == 1 then col = Color3.fromRGB(255,140,120)
	elseif kind == 2 then col = Color3.fromRGB(255,240,200)
	else col = Color3.fromRGB(255,210,120)
	end
	local ui = Instance.new("Frame")
	ui.BorderSizePixel = 0
	ui.BackgroundColor3 = col
	ui.BackgroundTransparency = 0.0
	ui.Size = UDim2.fromOffset(1, 1)
	ui.Position = UDim2.fromOffset(0,0)
	ui.ZIndex = UI.partLayer.ZIndex
	ui.Parent = UI.partLayer
	table.insert(parts, {x=x,y=y,vx=vx,vy=vy,t=0,life=life,ui=ui})
end

local function hitSpark(x, y)
	for i=1,6 do
		local a = math.random()*math.pi*2
		local sp = 18 + math.random()*37
		spawnParticle(x, y, math.cos(a)*sp, math.sin(a)*sp, 0.10 + math.random()*0.10, 0)
	end
end

local function popFX(x, y, n)
	for i=1,n do
		local a = math.random()*math.pi*2
		local sp = 10 + math.random()*32
		spawnParticle(x, y, math.cos(a)*sp, math.sin(a)*sp, 0.18 + math.random()*0.25, 1)
	end
end

local function muzzleSpark(x, y, dx, dy)
	for i=1,2 do
		spawnParticle(x, y, dx*(18 + math.random()*8), dy*(18 + math.random()*8), 0.06 + math.random()*0.05, 3)
	end
end

local pl = {
	maxHp=5, hp=5,
	level=1, xp=0, xpToNext=18, wantLevelUp=false,
	damage=1, fireCD=0, fireRate=0.14, bulletSp=74,
	shotCount=1, backShot=false, sideShot=false, pierce=0,
	pickupR=18, dashCD=0, dashBaseCD=1.2,
	invulnT=0, invuln=false,
	auraR=0, auraDps=0, auraAcc=0,
	critChance=0,
	lastAimX=1, lastAimY=0,
	fireHeld=false,
	touchAim=false, touchId=nil, touchScreenX=0, touchScreenY=0,
	char=nil, hum=nil, root=nil,
	ui=nil, auraRing=nil, auraHost=nil, auraRadLast=-1
}

local enemies = {}
local bullets = {}
local xps = {}
local picks = {}
local marks = {}

local savedX, savedY = WORLD_W*0.5, WORLD_H*0.5

local function upgradeAllowed(id)
	if id==3 and pl.shotCount>=3 then return false end
	if id==4 and pl.backShot then return false end
	if id==5 and pl.sideShot then return false end
	if id==6 and pl.auraR>=46 then return false end
	if id==7 and pl.pierce>=3 then return false end
	if id==1 and pl.fireRate<=0.055 then return false end
	if id==8 and pl.dashBaseCD<=0.55 then return false end
	return true
end

local function applyUpgrade(id)
	if id==0 then pl.damage += 1
	elseif id==1 then pl.fireRate = math.max(0.05, pl.fireRate * 0.88)
	elseif id==2 then pl.pickupR += 8
	elseif id==3 then pl.shotCount = math.min(3, pl.shotCount + 1)
	elseif id==4 then pl.backShot = true
	elseif id==5 then pl.sideShot = true
	elseif id==6 then pl.auraR = math.min(50, pl.auraR + 10) pl.auraDps += 0.35
	elseif id==7 then pl.pierce = math.min(3, pl.pierce + 1)
	elseif id==8 then pl.dashBaseCD = math.max(0.5, pl.dashBaseCD * 0.85)
	elseif id==9 then pl.maxHp += 1 pl.hp = math.min(pl.maxHp, pl.hp + 1)
	elseif id==10 then pl.bulletSp = math.min(120, pl.bulletSp * 1.12)
	elseif id==11 then pl.critChance = math.min(0.22, pl.critChance + 0.05)
	end
	popFX(savedX, savedY, 10)
	shake(0.06, 1.7)
end

local function pick3Upgrades()
	local out = {}
	local tries = 0
	while #out < 3 and tries < 300 do
		tries += 1
		local u = upgrades[math.random(1, #upgrades)]
		if upgradeAllowed(u.id) then
			local dup=false
			for _,p in ipairs(out) do if p.id==u.id then dup=true end end
			if not dup then table.insert(out, u) end
		end
	end
	while #out < 3 do
		table.insert(out, {id=2,name="PICKUP RADIUS",desc="COLLECT FARTHER"})
	end
	return out
end

local currentUp = nil

local function showLevelUp()
	currentUp = pick3Upgrades()
	UI.t1.Text = currentUp[1].name
	UI.sub1.Text = currentUp[1].desc
	UI.t2.Text = currentUp[2].name
	UI.sub2.Text = currentUp[2].desc
	UI.t3.Text = currentUp[3].name
	UI.sub3.Text = currentUp[3].desc
	mkIcon(UI.ico1, currentUp[1].id)
	mkIcon(UI.ico2, currentUp[2].id)
	mkIcon(UI.ico3, currentUp[3].id)
	setState(STATE_LEVEL)
end

UI.opt1.MouseButton1Click:Connect(function() if state==STATE_LEVEL then applyUpgrade(currentUp[1].id) setState(STATE_PLAY) end end)
UI.opt2.MouseButton1Click:Connect(function() if state==STATE_LEVEL then applyUpgrade(currentUp[2].id) setState(STATE_PLAY) end end)
UI.opt3.MouseButton1Click:Connect(function() if state==STATE_LEVEL then applyUpgrade(currentUp[3].id) setState(STATE_PLAY) end end)

local function getPlayerXY()
	if not pl.root then return savedX, savedY end
	return pl.root.Position.X, pl.root.Position.Z
end

local function forceStayOnFloor()
	if not pl.root then return end
	local p = pl.root.Position
	pl.root.CFrame = CFrame.new(p.X, FLOOR_Y, p.Z)
	pl.root.AssemblyLinearVelocity = Vector3.new(0,0,0)
	pl.root.AssemblyAngularVelocity = Vector3.new(0,0,0)
end

local function setPlayerXY(x,y)
	if not pl.root then
		savedX, savedY = x, y
		return
	end
	x = clamp(x, 8, WORLD_W-8)
	y = clamp(y, 8, WORLD_H-8)
	pl.root.CFrame = CFrame.new(x, FLOOR_Y, y)
	pl.root.AssemblyLinearVelocity = Vector3.new(0,0,0)
	pl.root.AssemblyAngularVelocity = Vector3.new(0,0,0)
	savedX, savedY = x, y
end

local function resolveObstacles(x,y,r,vx,vy)
	for _,lm in ipairs(marks) do
		if lm.solid then
			local rr = r + lm.r*0.72
			local dx = x - lm.x
			local dy = y - lm.y
			local d2 = dx*dx + dy*dy
			if d2 < rr*rr and d2 > 1e-4 then
				local d = math.sqrt(d2)
				local push = rr - d
				local nx = dx/d
				local ny = dy/d
				x += nx*push
				y += ny*push
				vx *= 0.75
				vy *= 0.75
			end
		end
	end
	x = clamp(x, 8, WORLD_W-8)
	y = clamp(y, 8, WORLD_H-8)
	return x,y,vx,vy
end

local function genLandmarks()
	marks = {}
	clearChildren(UI.marksLayer)
	local n = 240
	for i=1,n do
		local x = math.random(20, WORLD_W-20)
		local y = math.random(20, WORLD_H-20)
		local d = dist(x,y, WORLD_W*0.5, WORLD_H*0.5)
		if d >= 140 then
			local t = math.random(0,3)
			local r = (t==0) and (9 + math.random()*5) or ((t==1) and (6 + math.random()*6) or ((t==2) and (7 + math.random()*5) or (6 + math.random()*3)))
			local solid = (t==1 or t==2)
			local ui = mkLandmarkSprite(UI.marksLayer, t, r)
			table.insert(marks, {x=x,y=y,r=r,t=t,solid=solid,ui=ui})
		end
	end
end

local function resetGame()
	score = 0
	spawnTimer = 0
	spawnInterval = 1.05
	shakeT = 0
	shakeAmp = 0
	enemies = {}
	bullets = {}
	xps = {}
	picks = {}
	parts = {}
	clearChildren(UI.enemyLayer)
	clearChildren(UI.bulletLayer)
	clearChildren(UI.xpLayer)
	clearChildren(UI.pickLayer)
	clearChildren(UI.partLayer)
	clearChildren(UI.playerLayer)

	pl.maxHp=5 pl.hp=5
	pl.level=1 pl.xp=0 pl.xpToNext=18 pl.wantLevelUp=false
	pl.damage=1 pl.fireCD=0 pl.fireRate=0.14 pl.bulletSp=74
	pl.shotCount=1 pl.backShot=false pl.sideShot=false pl.pierce=0
	pl.pickupR=18 pl.dashCD=0 pl.dashBaseCD=1.2
	pl.invulnT=0 pl.invuln=false
	pl.auraR=0 pl.auraDps=0 pl.auraAcc=0
	pl.critChance=0
	pl.lastAimX=1 pl.lastAimY=0
	pl.fireHeld=false
	pl.touchAim=false pl.touchId=nil
	pl.auraRadLast=-1

	pl.ui, pl.auraRing, pl.auraHost = mkPlayerSprite(UI.playerLayer)

	genLandmarks()

	savedX, savedY = WORLD_W*0.5, WORLD_H*0.5
	setPlayerXY(savedX, savedY)
end

local function spawnEnemy()
	local px, py = getPlayerXY()
	local ang = math.random()*math.pi*2
	local distSpawn = 120 + math.random()*80
	local x = clamp(px + math.cos(ang)*distSpawn, 8, WORLD_W-8)
	local y = clamp(py + math.sin(ang)*distSpawn, 8, WORLD_H-8)

	local roll = math.random(1,100)
	local typ = 0
	if roll >= 70 and roll < 92 then typ = 1 end
	if roll >= 92 then typ = 2 end

	local diff = 1 + score*0.02 + pl.level*0.55
	local r = (typ==2) and (6 + math.random()*1.3) or (3.8 + math.random()*2.0)
	local hpBase = (typ==0) and 3 or ((typ==1) and 4 or 10)
	local hp = hpBase + diff*0.7 + math.random(0,2)
	local sp = (typ==0) and (18 + diff*0.65) or ((typ==1) and (15 + diff*0.55) or (11 + diff*0.35))

	local ui, shieldRing, shieldHost = mkEnemySprite(UI.enemyLayer, typ)
	table.insert(enemies, {x=x,y=y,vx=0,vy=0,r=r,hp=hp,sp=sp,typ=typ,t=0,ui=ui,shieldRing=shieldRing,shieldHost=shieldHost,shieldRadLast=-1})
end

local function killEnemy(e)
	score += (e.typ==0 and 1 or (e.typ==1 and 2 or 5))
	popFX(e.x, e.y, 18)
	shake(0.06, 2.0)
	if e.ui then e.ui:Destroy() end

	local xpCount = (e.typ==2) and math.random(6,9) or math.random(2,4)
	for i=1,xpCount do
		local a = math.random()*math.pi*2
		local spd = 10 + math.random()*30
		local ui = mkXpSprite(UI.xpLayer)
		table.insert(xps, {x=e.x,y=e.y,vx=math.cos(a)*spd,vy=math.sin(a)*spd,t=0,ui=ui,val=1})
	end

	if math.random() < 0.08 then
		local kind = math.random(0,2)
		local ui = mkPickupSprite(UI.pickLayer, kind)
		table.insert(picks, {x=e.x,y=e.y,vx=0,vy=0,t=0,kind=kind,ui=ui})
	end
end

local function shoot(dirx, diry)
	local px, py = getPlayerXY()

	local function addShot(dx,dy)
		local bx = px + dx*6
		local by = py + dy*6
		local dmg = pl.damage
		if math.random() < pl.critChance then
			dmg += math.max(1, math.floor(dmg*1.2))
		end
		local col = (pl.pierce>0) and Color3.fromRGB(255,240,160) or Color3.fromRGB(255,210,120)
		local ui = mkBulletSprite(UI.bulletLayer, col)
		table.insert(bullets, {x=bx,y=by,vx=dx*pl.bulletSp,vy=dy*pl.bulletSp,r=0.75,dmg=dmg,pierce=pl.pierce,life=0,ui=ui})
		muzzleSpark(bx, by, dx, dy)
	end

	local spread = 0.12
	local shots = pl.shotCount
	for i=1,shots do
		local ang = 0
		if shots==2 then ang = (i==1) and -spread or spread end
		if shots==3 then ang = (i==1) and -spread or ((i==2) and 0 or spread) end
		local c = math.cos(ang) local s = math.sin(ang)
		local dx = dirx*c - diry*s
		local dy = dirx*s + diry*c
		local m = math.sqrt(dx*dx+dy*dy)
		if m > 1e-6 then dx/=m dy/=m end
		addShot(dx,dy)
	end
	if pl.backShot then addShot(-dirx, -diry) end
	if pl.sideShot then
		addShot(-diry, dirx)
		addShot(diry, -dirx)
	end
end

local function gainXP(v)
	pl.xp += v
	if pl.xp >= pl.xpToNext then
		pl.xp -= pl.xpToNext
		pl.level += 1
		pl.xpToNext = math.floor(18 + (pl.level^1.35)*6.0)
		pl.wantLevelUp = true
	end
end

local function updateHUD()
	UI.scoreLbl.Text = "SCORE "..tostring(score)
	UI.lvlLbl.Text = "LV "..tostring(pl.level)
	local t = (pl.xpToNext>0) and clamp(pl.xp/pl.xpToNext, 0, 1) or 0
	UI.xpFill.Size = UDim2.fromOffset(math.floor(96*t+0.5), 6)
	UI.xpTxt.Text = tostring(pl.xp).."/"..tostring(pl.xpToNext)

	for i=1,#UI.hearts do
		local h = UI.hearts[i]
		h.Visible = (i <= pl.maxHp)
		if i <= pl.hp then
			h.BackgroundColor3 = Color3.fromRGB(255,90,110)
			h.BackgroundTransparency = 0.05
		else
			h.BackgroundColor3 = Color3.fromRGB(70,70,85)
			h.BackgroundTransparency = 0.15
		end
	end

	if state==STATE_OVER then
		UI.overText.Text = "GAME OVER\n\nSCORE "..score.."\nBEST "..bestScore.."\n\nTAP/CLICK TO RESTART"
	end
end

local function updateVHS()
	UI.noise.BackgroundTransparency = 0.985 + (math.random()*0.012)
	UI.noise.Position = UDim2.fromOffset(math.random(-1,1), math.random(-1,1))
	UI.topBand.BackgroundTransparency = 0.990 + (math.random()*0.007)
	UI.topBand.Position = UDim2.fromOffset(math.random(-1,1), math.random(0,1))
end

local camX, camY = WORLD_W*0.5, WORLD_H*0.5

local function updateCamera2D()
	local px, py = getPlayerXY()
	camX = lerp(camX, px, 0.12)
	camY = lerp(camY, py, 0.12)
end

local function updateGridAndBorder()
	local vx0 = camX - BASE_W*0.5
	local vy0 = camY - BASE_H*0.5

	local startX = math.floor((vx0 - 80)/20)*20
	for i=1,#gridV do
		local worldX = startX + (i-1)*20
		local cx = math.floor((worldX - vx0) + 0.5)
		gridV[i].Position = UDim2.fromOffset(cx, 0)
	end

	local startY = math.floor((vy0 - 80)/20)*20
	for i=1,#gridH do
		local worldY = startY + (i-1)*20
		local cy = math.floor((worldY - vy0) + 0.5)
		gridH[i].Position = UDim2.fromOffset(0, cy)
	end

	local bx = (0 - camX) + BASE_W*0.5
	local by = (0 - camY) + BASE_H*0.5
	borderContainer.Position = UDim2.fromOffset(math.floor(bx+0.5), math.floor(by+0.5))
end

local function updateSprites(shakeOffX, shakeOffY)
	local function place(ui, wx, wy, extraVis)
		local cx = (wx - camX) + BASE_W*0.5 + shakeOffX
		local cy = (wy - camY) + BASE_H*0.5 + shakeOffY
		ui.Position = UDim2.fromOffset(math.floor(cx+0.5), math.floor(cy+0.5))
		local pad = extraVis or 40
		ui.Visible = (cx > -pad and cx < BASE_W+pad and cy > -pad and cy < BASE_H+pad)
		return cx, cy
	end

	for _,lm in ipairs(marks) do place(lm.ui, lm.x, lm.y, 90) end
	for _,o in ipairs(xps) do place(o.ui, o.x, o.y, 50) end
	for _,p in ipairs(picks) do place(p.ui, p.x, p.y, 50) end
	for _,b in ipairs(bullets) do place(b.ui, b.x, b.y, 50) end
	for _,e in ipairs(enemies) do place(e.ui, e.x, e.y, 80) end

	local px, py = getPlayerXY()
	if pl.ui then
		place(pl.ui, px, py, 80)
		if pl.invuln and (math.floor(tick()*12)%2==0) then
			pl.ui.Visible = false
		end
	end
end

local function updateReticle()
	if state ~= STATE_PLAY then
		UI.reticle.Position = UDim2.fromOffset(-9999, -9999)
		return
	end
	if UserInputService.TouchEnabled then
		if pl.touchAim then
			local cx, cy = screenToCanvas(pl.touchScreenX, pl.touchScreenY)
			UI.reticle.Position = UDim2.fromOffset(math.floor(cx+0.5), math.floor(cy+0.5))
		else
			UI.reticle.Position = UDim2.fromOffset(-9999, -9999)
		end
	else
		local mp = UserInputService:GetMouseLocation()
		local cx, cy = screenToCanvas(mp.X, mp.Y)
		UI.reticle.Position = UDim2.fromOffset(math.floor(cx+0.5), math.floor(cy+0.5))
	end
end

clearChildren(UI.reticle)
mkPixelCross(UI.reticle, Color3.fromRGB(90,220,255), 0.0, 4)

local function onCharacter(char)
	pl.char = char
	pl.hum = char:WaitForChild("Humanoid")
	pl.root = char:WaitForChild("HumanoidRootPart")

	pl.hum.AutoRotate = false
	pl.hum.WalkSpeed = 0
	pl.hum.JumpPower = 0

	for _,d in ipairs(char:GetDescendants()) do
		if d:IsA("BasePart") then
			d.CastShadow = false
			if d.Name ~= "HumanoidRootPart" then
				d.Transparency = 1
			end
		end
	end

	setPlayerXY(savedX, savedY)
	forceStayOnFloor()
end

lp.CharacterAdded:Connect(onCharacter)
if lp.Character then onCharacter(lp.Character) end

local dashQueued = false
ContextActionService:BindAction("NW_DASH", function(_, inputState)
	if inputState == Enum.UserInputState.Begin then
		if state==STATE_PLAY then dashQueued=true end
	end
	return Enum.ContextActionResult.Sink
end, false, Enum.KeyCode.Space, Enum.KeyCode.ButtonA)

local function computeAimDir()
	local px, py = getPlayerXY()
	if UserInputService.TouchEnabled then
		if pl.touchAim then
			local cx, cy = screenToCanvas(pl.touchScreenX, pl.touchScreenY)
			local wx, wy = canvasToWorld(cx, cy, camX, camY)
			local dx, dy = wx - px, wy - py
			local m = math.sqrt(dx*dx+dy*dy)
			if m > 1e-6 then return dx/m, dy/m end
		end
		return 0,0
	else
		local mp = UserInputService:GetMouseLocation()
		local cx, cy = screenToCanvas(mp.X, mp.Y)
		local wx, wy = canvasToWorld(cx, cy, camX, camY)
		local dx, dy = wx - px, wy - py
		local m = math.sqrt(dx*dx+dy*dy)
		if m > 1e-6 then return dx/m, dy/m end
		return 0,0
	end
end

local function resetTouchAim()
	pl.touchAim = false
	pl.touchId = nil
	pl.fireHeld = false
end

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		if state==STATE_TITLE then setState(STATE_PLAY) return end
		if state==STATE_OVER then resetGame() setState(STATE_PLAY) return end
		if state==STATE_PLAY then pl.fireHeld = true end
	end

	if input.UserInputType == Enum.UserInputType.Touch then
		local vp = cam.ViewportSize
		local x, y = normScreenXY(input.Position.X, input.Position.Y)

		if state==STATE_TITLE then setState(STATE_PLAY) return end
		if state==STATE_OVER then resetGame() setState(STATE_PLAY) return end

		if state==STATE_PLAY then
			if x > vp.X*0.52 then
				pl.touchAim = true
				pl.touchId = input
				pl.touchScreenX = input.Position.X
				pl.touchScreenY = input.Position.Y
				pl.fireHeld = true
			end
		end
	end
end)

UserInputService.InputChanged:Connect(function(input, gpe)
	if input.UserInputType == Enum.UserInputType.Touch then
		if pl.touchAim and pl.touchId == input then
			pl.touchScreenX = input.Position.X
			pl.touchScreenY = input.Position.Y
		end
	end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		pl.fireHeld = false
	end
	if input.UserInputType == Enum.UserInputType.Touch then
		if pl.touchId == input then
			resetTouchAim()
		end
	end
end)

resetGame()
setState(STATE_TITLE)

RunService.Heartbeat:Connect(function(dt)
	updateVHS()
	updateScale()
	updateReticle()

	if shakeT > 0 then shakeT -= dt end
	if pl.root then forceStayOnFloor() end

	updateCamera2D()
	updateGridAndBorder()

	local shakeOffX, shakeOffY = 0,0
	if shakeT > 0 then
		local a = shakeAmp * (shakeT * 12.0)
		shakeOffX = (math.random()*2-1) * a
		shakeOffY = (math.random()*2-1) * a
	end

	for i=#parts,1,-1 do
		local p = parts[i]
		p.t += dt
		p.x += p.vx*dt
		p.y += p.vy*dt
		p.vx *= (0.001^(dt))
		p.vy *= (0.001^(dt))
		local a = 1.0 - (p.t / p.life)
		a = clamp(a, 0, 1)
		if p.ui then
			local cx = (p.x - camX) + BASE_W*0.5 + shakeOffX
			local cy = (p.y - camY) + BASE_H*0.5 + shakeOffY
			p.ui.Position = UDim2.fromOffset(math.floor(cx+0.5), math.floor(cy+0.5))
			p.ui.BackgroundTransparency = 1 - a
		end
		if p.t >= p.life then
			if p.ui then p.ui:Destroy() end
			table.remove(parts,i)
		end
	end

	if state ~= STATE_PLAY then
		updateSprites(shakeOffX, shakeOffY)
		updateHUD()
		return
	end

	if not pl.root or not pl.hum then
		updateHUD()
		return
	end

	local px, py = getPlayerXY()

	local dirx, diry = computeAimDir()
	if math.abs(dirx) + math.abs(diry) > 0 then
		pl.lastAimX = dirx
		pl.lastAimY = diry
	end

	pl.fireCD = math.max(0, pl.fireCD - dt)
	pl.dashCD = math.max(0, pl.dashCD - dt)
	pl.invulnT = math.max(0, pl.invulnT - dt)
	pl.invuln = (pl.invulnT > 0)

	local mv = pl.hum.MoveDirection
	local mx, my = mv.X, mv.Z
	local sp = 46
	local nx = px + mx*sp*dt
	local ny = py + my*sp*dt

	local vx = (nx - px) / math.max(1e-6, dt)
	local vy = (ny - py) / math.max(1e-6, dt)

	if dashQueued and pl.dashCD <= 0 then
		dashQueued = false
		local dx, dy = mx, my
		local m = math.sqrt(dx*dx+dy*dy)
		if m < 0.15 then dx, dy = pl.lastAimX, pl.lastAimY m = math.sqrt(dx*dx+dy*dy) end
		if m < 1e-6 then dx, dy = 1,0 m=1 end
		dx/=m dy/=m
		vx += dx*170
		vy += dy*170
		pl.dashCD = pl.dashBaseCD
		pl.invulnT = 0.22
		popFX(px, py, 10)
		shake(0.08, 2.2)
	else
		dashQueued = false
	end

	nx, ny, vx, vy = resolveObstacles(nx, ny, 5.0, vx, vy)
	setPlayerXY(nx, ny)
	px, py = nx, ny

	if pl.fireHeld and pl.fireCD <= 0 then
		pl.fireCD = pl.fireRate
		shoot(pl.lastAimX, pl.lastAimY)
	end

	local diff = 1 + score*0.02 + pl.level*0.55
	spawnInterval = math.max(0.25, 1.05 - diff*0.04)

	spawnTimer -= dt
	if spawnTimer <= 0 then
		spawnTimer = spawnInterval
		spawnEnemy()
	end

	if pl.auraR > 0 and pl.auraDps > 0 then
		pl.auraAcc += dt * pl.auraDps
		local ticks = math.floor(pl.auraAcc)
		if ticks > 0 then
			pl.auraAcc -= ticks
			for _=1,ticks do
				for i=#enemies,1,-1 do
					local e = enemies[i]
					if dist(e.x,e.y, px,py) < (pl.auraR + e.r) then
						e.hp -= 1
						if e.hp <= 0 then
							killEnemy(e)
							table.remove(enemies,i)
						end
					end
				end
			end
		end
	end

	for i=#picks,1,-1 do
		local p = picks[i]
		p.t += dt
		local d = dist(p.x,p.y, px, py)
		if d < pl.pickupR then
			local dx = px - p.x
			local dy = py - p.y
			local m = math.sqrt(dx*dx+dy*dy)
			if m > 1e-6 then
				local ux, uy = dx/m, dy/m
				local spd = (1 - (d/pl.pickupR))*110 + 40
				p.vx = lerp(p.vx, ux*spd, 0.25)
				p.vy = lerp(p.vy, uy*spd, 0.25)
			end
		end
		p.x += p.vx*dt
		p.y += p.vy*dt
		p.vx *= 0.94^(dt*60)
		p.vy *= 0.94^(dt*60)

		if d < 5 then
			if p.kind==0 then pl.hp = math.min(pl.maxHp, pl.hp+1)
			elseif p.kind==1 then gainXP(6)
			elseif p.kind==2 then pl.invulnT = math.max(pl.invulnT, 0.9)
			end
			popFX(p.x, p.y, 10)
			if p.ui then p.ui:Destroy() end
			table.remove(picks,i)
			shake(0.05, 1.4)
		elseif p.t > 18 then
			if p.ui then p.ui:Destroy() end
			table.remove(picks,i)
		end
	end

	for i=#xps,1,-1 do
		local o = xps[i]
		o.t += dt
		local d = dist(o.x,o.y, px, py)
		local pullR = pl.pickupR + 18
		if d < pullR then
			local dx = px - o.x
			local dy = py - o.y
			local m = math.sqrt(dx*dx+dy*dy)
			if m > 1e-6 then
				local ux, uy = dx/m, dy/m
				local spd = (1 - (d/pullR))*160 + 30
				o.vx = lerp(o.vx, ux*spd, 0.18)
				o.vy = lerp(o.vy, uy*spd, 0.18)
			end
		end
		o.x += o.vx*dt
		o.y += o.vy*dt
		o.vx *= 0.98^(dt*60)
		o.vy *= 0.98^(dt*60)

		if d < 4.2 then
			gainXP(o.val)
			for k=1,3 do spawnParticle(o.x, o.y, (math.random()*2-1)*25, (math.random()*2-1)*25, 0.08 + math.random()*0.08, 2) end
			if o.ui then o.ui:Destroy() end
			table.remove(xps,i)
			shake(0.02, 0.9)
		elseif o.t > 25 then
			if o.ui then o.ui:Destroy() end
			table.remove(xps,i)
		end
	end

	for i=#bullets,1,-1 do
		local b = bullets[i]
		b.life += dt
		b.x += b.vx*dt
		b.y += b.vy*dt
		if b.x < -80 or b.x > WORLD_W+80 or b.y < -80 or b.y > WORLD_H+80 or b.life > 2.6 then
			if b.ui then b.ui:Destroy() end
			table.remove(bullets,i)
		else
			for j=#enemies,1,-1 do
				local e = enemies[j]
				if dist(b.x,b.y, e.x,e.y) < (e.r + b.r) then
					e.hp -= b.dmg
					hitSpark(b.x, b.y)
					shake(0.03, 1.1)
					if b.pierce > 0 then
						b.pierce -= 1
					else
						if b.ui then b.ui:Destroy() end
						table.remove(bullets,i)
					end
					if e.hp <= 0 then
						killEnemy(e)
						table.remove(enemies,j)
					end
					break
				end
			end
		end
	end

	for i=#enemies,1,-1 do
		local e = enemies[i]
		e.t += dt
		local dx = px - e.x
		local dy = py - e.y
		local d = math.sqrt(dx*dx + dy*dy)
		local ux, uy = 1, 0
		if d > 1e-6 then ux, uy = dx/d, dy/d end

		local sx = ux*e.sp
		local sy = uy*e.sp
		if e.typ==1 then
			local wig = math.sin(e.t*6.0)*0.9
			sx += (-uy) * wig * e.sp * 0.75
			sy += ( ux) * wig * e.sp * 0.75
		elseif e.typ==2 then
			sx *= 0.55
			sy *= 0.55
		end

		e.vx = lerp(e.vx, sx, 0.08)
		e.vy = lerp(e.vy, sy, 0.08)
		e.x += e.vx*dt
		e.y += e.vy*dt
		e.x, e.y, e.vx, e.vy = resolveObstacles(e.x, e.y, e.r*0.9, e.vx, e.vy)

		if not pl.invuln and dist(e.x,e.y, px,py) < (e.r + 4.6) then
			if pl.invulnT <= 0 then
				pl.hp -= 1
				pl.invulnT = 0.60
				popFX(px, py, 16)
				shake(0.10, 2.8)
			end
			local kx, ky = e.x - px, e.y - py
			local km = math.sqrt(kx*kx + ky*ky)
			if km < 1e-6 then km=1 kx,ky=1,0 end
			kx, ky = (kx/km)*14, (ky/km)*14
			e.vx += kx
			e.vy += ky
		end
	end

	if pl.hp <= 0 then
		bestScore = math.max(bestScore, score)
		setState(STATE_OVER)
	end

	if pl.wantLevelUp then
		pl.wantLevelUp = false
		showLevelUp()
	end

	if pl.auraHost then
		if pl.auraR > 0 then
			local rad = math.floor(pl.auraR + 0.5)
			if rad ~= pl.auraRadLast then
				pl.auraRadLast = rad
				clearChildren(pl.auraHost)
				pl.auraRing = mkPixelRing(pl.auraHost, rad, Color3.fromRGB(90,220,255), 0.55)
				pl.auraRing.Visible = true
			end
			pl.auraHost.Visible = true
		else
			pl.auraHost.Visible = false
		end
	end

	for _,e in ipairs(enemies) do
		if e.shieldHost and e.shieldRing then
			local show = (e.typ==2) or (e.hp >= 5)
			if show then
				local rad = (e.typ==2) and 9 or 7
				if rad ~= e.shieldRadLast then
					e.shieldRadLast = rad
					clearChildren(e.shieldHost)
					e.shieldRing = mkPixelRing(e.shieldHost, rad, Color3.fromRGB(255,255,255), 0.70)
					e.shieldRing.Visible = true
				end
				e.shieldHost.Visible = true
			else
				e.shieldHost.Visible = false
			end
		end
	end

	updateSprites(shakeOffX, shakeOffY)
	updateHUD()
end)
